<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Porous Fin LTNE — AGM (Nu components)</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
:root{--bg:#0f1115;--card:#171a21;--ink:#e9eefb;--muted:#9fb2d2;--accent:#6aa5ff}
body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.4 system-ui,Segoe UI,Roboto,Arial}
header{padding:18px 22px;border-bottom:1px solid #222}
h1{margin:0;font-size:20px}
.wrap{display:grid;grid-template-columns:330px 1fr;gap:18px;padding:18px}
.card{background:var(--card);border:1px solid #222;border-radius:14px;padding:16px}
.row{display:flex;gap:10px;align-items:center;margin:10px 0}
.row label{flex:0 0 120px;color:var(--muted)}
.row input[type=range]{width:100%}
.val{width:80px;text-align:right;color:var(--accent);font-variant-numeric:tabular-nums}
.small{color:var(--muted);font-size:12px;margin-top:6px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
button{background:#1e2633;color:#dce7ff;border:1px solid #293248;border-radius:10px;padding:8px 10px;cursor:pointer}
button:hover{background:#253043}
a.dl{color:#cfe0ff;text-decoration:underline;font-size:13px;margin-left:8px}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
<header><h1>Porous Fin LTNE — AGM with Nu<sub>f</sub>, Nu<sub>s</sub>, Nu<sub>t</sub></h1></header>

<div class="wrap">
  <div class="card">
    <div class="row"><label>Bi</label>
      <input id="bi" type="range" min="1" max="1000" step="1" value="100">
      <div class="val" id="bi_v">100</div>
    </div>
    <div class="row"><label>Ra</label>
      <input id="ra" type="range" min="0" max="100" step="1" value="50">
      <div class="val" id="ra_v">50</div>
    </div>
    <div class="row"><label>κ = k_s/k_f</label>
      <input id="kappa" type="range" min="1" max="10000" step="1" value="1000">
      <div class="val" id="kappa_v">1000</div>
    </div>
    <div class="row"><label>τ = t/L</label>
      <input id="tau" type="range" min="0.02" max="0.4" step="0.01" value="0.10">
      <div class="val" id="tau_v">0.10</div>
    </div>
    <div class="row"><label>α (decay)</label>
      <input id="alpha" type="range" min="0.2" max="2.0" step="0.01" value="0.86">
      <div class="val" id="alpha_v">0.86</div>
    </div>
    <div class="row"><label>m<sub>f</sub> (exp terms)</label>
      <input id="mf" type="range" min="3" max="16" step="1" value="8">
      <div class="val" id="mf_v">8</div>
    </div>
    <div class="row"><label>m<sub>s</sub> (poly deg)</label>
      <input id="ms" type="range" min="2" max="10" step="1" value="6">
      <div class="val" id="ms_v">6</div>
    </div>

    <div class="row">
      <button id="run">Solve AGM</button>
      <a id="csv_link" class="dl" href="#" download="agm_profile.csv" style="display:none">download CSV</a>
    </div>

    <div class="small">
      \(Nu_f=-\frac{\phi k_f}{k_{eq}}\tau\,\theta_f'(0)\), 
      \(Nu_s=-\frac{k_{\mathrm{eff}}}{k_{eq}}\tau\,\theta_s'(0)\), 
      \(Nu_t=Nu_f+Nu_s\).<br>
      \(k_{\mathrm{eff}}=(1-\phi)k_s+\frac{16\sigma T_\infty^3}{3\beta_R}\), 
      \(k_{eq}=\phi k_f+(1-\phi)k_s\).  BCs: \(\theta_f(0)=\theta_s(0)=1\), \(\theta'_f(1)=\theta'_s(1)=0\).
    </div>
  </div>

  <div class="grid2">
    <div class="card"><div id="plot_theta" style="height:430px"></div></div>
    <div class="card"><div id="plot_nu" style="height:430px"></div></div>
  </div>
</div>

<script>
const linspace=(a,b,n)=>Array.from({length:n},(_,i)=>a+(b-a)*i/(n-1));
function chebyshevNodes(n){const xs=[];for(let k=1;k<=n;k++){const z=Math.cos((2*k-1)/(2*n)*Math.PI);xs.push(0.5*(1+z));}xs.sort((p,q)=>p-q);return xs;}
function solveLinear(A,b){const n=A.length;for(let i=0;i<n;i++)A[i]=A[i].slice().concat([b[i]]);
  for(let col=0;col<n;col++){let piv=col,mx=Math.abs(A[col][col]);for(let r=col+1;r<n;r++){const v=Math.abs(A[r][col]);if(v>mx){mx=v;piv=r;}}
    if(mx<1e-14)throw new Error("Singular");if(piv!==col){const t=A[piv];A[piv]=A[col];A[col]=t;}
    const pv=A[col][col];for(let j=col;j<=n;j++)A[col][j]/=pv;
    for(let r=0;r<n;r++){if(r===col)continue;const f=A[r][col];if(Math.abs(f)<1e-15)continue;for(let j=col;j<=n;j++)A[r][j]-=f*A[col][j];}}
  return A.map(r=>r[n]);}

function modelParams(Bi,Ra,kappa){
  const phi=0.92, rdEff=0.1, R1=0.3, kf=1.0, ks=kappa*kf;
  const Keff=(1-phi)*ks + 16*rdEff/3;      // Rosseland bump
  const keq=phi*kf + (1-phi)*ks;           // reference mix
  const H=Bi*0.1;                          // interfacial exchange
  const Sf=Ra*0.02;                        // buoyancy linearization
  const E=R1*0.2;                          // external sink
  return {phi,kf,ks,Keff,keq,H,Sf,E};
}

function buildAGM(Bi,Ra,kappa,alpha,mf,ms){
  const {phi,kf,ks,Keff,keq,H,Sf,E}=modelParams(Bi,Ra,kappa);
  const nf=mf+1, ns=ms+1, nUnknown=nf+ns, nCol=Math.max(nUnknown, 2*(mf+ms)+6);
  const xs=chebyshevNodes(Math.max(8, Math.ceil(nCol/2)));
  const ef=(i,x)=>Math.exp(-alpha*i*x);
  const ef_d =(i,x)=>-(alpha*i)*Math.exp(-alpha*i*x);
  const ef_d2=(i,x)=>(alpha*alpha*i*i)*Math.exp(-alpha*i*x);
  const ps=(i,x)=>Math.pow(x,i);
  const ps_d=(i,x)=>i>=1? i*Math.pow(x,i-1):0;
  const ps_d2=(i,x)=>i>=2? i*(i-1)*Math.pow(x,i-2):0;

  const A=[], b=[];
  function push(row,rhs){A.push(row);b.push(rhs);}

  // Fluid ODE: φ kf θf'' - H(θs-θf) - Sf θf = 0
  for(const x of xs){
    const row=new Array(nUnknown).fill(0);
    for(let i=0;i<nf;i++) row[i]+= (phi*kf)*ef_d2(i,x);
    for(let i=0;i<nf;i++) row[i]+=  H*ef(i,x) - Sf*ef(i,x);
    for(let j=0;j<ns;j++) row[nf+j]+= -H*ps(j,x);
    push(row,0);
  }
  // Solid ODE: Keff θs'' - H(θf-θs) + E θs = 0
  for(const x of xs){
    const row=new Array(nUnknown).fill(0);
    for(let j=0;j<ns;j++) row[nf+j]+= Keff*ps_d2(j,x) + E*ps(j,x);
    for(let i=0;i<nf;i++) row[i]+= -H*ef(i,x);
    for(let j=0;j<ns;j++) row[nf+j]+=  H*ps(j,x);
    push(row,0);
  }
  // BCs
  {const r=new Array(nUnknown).fill(0); for(let i=0;i<nf;i++) r[i]+=1; push(r,1);}              // θf(0)=1
  {const r=new Array(nUnknown).fill(0); r[nf+0]=1; push(r,1);}                                  // θs(0)=1
  {const r=new Array(nUnknown).fill(0); for(let i=0;i<nf;i++) r[i]+=ef_d(i,1.0); push(r,0);}    // θf'(1)=0
  {const r=new Array(nUnknown).fill(0); for(let j=1;j<ns;j++) r[nf+j]+=j; push(r,0);}           // θs'(1)=0

  // Solve (least squares if overdetermined)
  let coeff;
  if(A.length===nUnknown){ coeff=solveLinear(A.map(r=>r.slice()), b.slice()); }
  else{
    const m=A.length,n=nUnknown, ATA=Array.from({length:n},()=>Array(n).fill(0)), ATb=Array(n).fill(0);
    for(let i=0;i<m;i++){const r=A[i], bi=b[i];
      for(let p=0;p<n;p++){ATb[p]+=r[p]*bi; for(let q=0;q<n;q++) ATA[p][q]+=r[p]*r[q];}}
    coeff=solveLinear(ATA,ATb);
  }
  const a=coeff.slice(0,nf), d=coeff.slice(nf);

  function theta_f(x){let s=0; for(let i=0;i<nf;i++) s+=a[i]*Math.exp(-alpha*i*x); return s;}
  function theta_s(x){let s=0; for(let j=0;j<ns;j++) s+=d[j]*Math.pow(x,j); return s;}
  function dthetaf_dx(x){let s=0; for(let i=0;i<nf;i++) s+=a[i]*(-(alpha*i))*Math.exp(-alpha*i*x); return s;}
  function dthetas_dx(x){let s=0; for(let j=1;j<ns;j++) s+=j*d[j]*Math.pow(x,j-1); return s;}

  return {theta_f,theta_s,dthetaf_dx,dthetas_dx, a,d, phi,kf,ks,Keff,keq};
}

function solveAndPlot(){
  const Bi=+bi.value, Ra=+ra.value, kappa=+kappaEl.value, tau=+tau.value, alpha=+alphaEl.value, mf=+mfEl.value, ms=+msEl.value;
  bi_v.textContent=Bi; ra_v.textContent=Ra; kappa_v.textContent=kappa; tau_v.textContent=tau.toFixed(2);
  alpha_v.textContent=alpha.toFixed(2); mf_v.textContent=mf; ms_v.textContent=ms;

  const agm=buildAGM(Bi,Ra,kappa,alpha,mf,ms);
  const x=linspace(0,1,201);
  const yf=x.map(agm.theta_f), ys=x.map(agm.theta_s);

  // Base slopes
  const df0 = agm.dthetaf_dx(0);
  const ds0 = agm.dthetas_dx(0);

  // Nu components using your exact formula
  const Nu_f = -(agm.phi*agm.kf / agm.keq) * tau * df0;
  const Nu_s = -(agm.Keff     / agm.keq) * tau * ds0;
  const Nu_t = Nu_f + Nu_s;

  // Plot theta
  Plotly.newPlot("plot_theta",[
    {x, y:yf, name:"θf (fluid)", mode:"lines"},
    {x, y:ys, name:"θs (solid)", mode:"lines"}
  ],{
    paper_bgcolor:'transparent', plot_bgcolor:'transparent',
    margin:{l:55,r:10,t:10,b:44},
    xaxis:{title:'x',gridcolor:'#2a3242',color:'#cfe0ff'},
    yaxis:{title:'θ',gridcolor:'#2a3242',color:'#cfe0ff'},
    legend:{font:{color:'#cfe0ff'}}
  },{displayModeBar:false});

  // Plot Nu components (stacked bars)
  Plotly.newPlot("plot_nu",[
    {x:["Nu_f","Nu_s","Nu_t"], y:[Nu_f, Nu_s, Nu_t],
     type:"bar", name:"components", marker:{}, hovertemplate:"%{x}: %{y:.4f}<extra></extra>"}
  ],{
    paper_bgcolor:'transparent', plot_bgcolor:'transparent',
    margin:{l:70,r:10,t:10,b:44},
    yaxis:{title:'Nusselt',gridcolor:'#2a3242',color:'#cfe0ff'},
    xaxis:{color:'#cfe0ff'},
    annotations:[{x:"Nu_t", y:Nu_t, text:`Nu_t = ${Nu_t.toFixed(4)}`, showarrow:false, yshift:16, font:{color:'#9fd1ff'}}]
  },{displayModeBar:false});

  // Build CSV and expose download link
  const rows=["x,theta_f,theta_s"];
  for(let i=0;i<x.length;i++) rows.push(`${x[i].toFixed(5)},${yf[i].toFixed(8)},${ys[i].toFixed(8)}`);
  const blob=new Blob([rows.join("\n")],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const link=document.getElementById("csv_link");
  link.href=url; link.style.display="inline"; // click to download current profile
}

// controls
const bi=document.getElementById("bi"), ra=document.getElementById("ra"), kappaEl=document.getElementById("kappa"),
      tau=document.getElementById("tau"), alphaEl=document.getElementById("alpha"),
      mfEl=document.getElementById("mf"), msEl=document.getElementById("ms");
const bi_v=document.getElementById("bi_v"), ra_v=document.getElementById("ra_v"),
      kappa_v=document.getElementById("kappa_v"), tau_v=document.getElementById("tau_v"),
      alpha_v=document.getElementById("alpha_v"), mf_v=document.getElementById("mf_v"), ms_v=document.getElementById("ms_v");

document.getElementById("run").addEventListener("click", solveAndPlot);

// optional: live preview while sliding, but “Solve AGM” still exports CSV & redraws bars
[bi,ra,kappaEl,tau,alphaEl,mfEl,msEl].forEach(el=> el.addEventListener("input", solveAndPlot));

solveAndPlot();
</script>
</body>
</html>
