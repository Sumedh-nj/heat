<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Porous Fin LTNE — AGM only (Fig 1b)</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
:root{--bg:#0f1115;--card:#171a21;--ink:#e9eefb;--muted:#9fb2d2;--accent:#6aa5ff;--grid:#273043;--line:#232838}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,Segoe UI,Roboto,Arial}
header{padding:18px 22px;border-bottom:1px solid var(--line)}
h1{margin:0;font-size:20px}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:18px}
@media (max-width:1200px){.wrap{grid-template-columns:1fr}}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px}
.row{display:grid;grid-template-columns:130px 1fr 72px;gap:10px;align-items:center;margin:10px 0}
.row label{color:var(--muted);font-size:13px}
.row input[type=range]{width:100%}
.val{width:72px;text-align:right;color:var(--accent);font-variant-numeric:tabular-nums}
.hint{color:#b7c6e6;font-size:11px;margin-top:2px}
.grid3{display:grid;grid-template-columns:1fr 1fr 0.9fr;gap:12px}
@media (max-width:1200px){.grid3{grid-template-columns:1fr}}
button{background:#1e2633;color:#dce7ff;border:1px solid #2a3242;border-radius:10px;padding:8px 10px;cursor:pointer}
button:hover{background:#253043}
.small{color:#9fb2d2;font-size:12px;margin-top:6px}
.kv{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
.badge{display:inline-block;background:#202a40;border:1px solid #2f3b54;border-radius:10px;padding:2px 8px;margin-right:6px;font-size:12px}
select{width:100%;background:#101522;color:#e8f0ff;border:1px solid #2a3242;border-radius:10px;padding:8px}
.desc{color:#cbd8f5;font-size:12px;margin-top:6px;min-height:32px}
</style>
</head>
<body>
<header><h1>Porous Fin LTNE — AGM only (Fig 1b: θ<sub>f</sub>, θ<sub>s</sub>, and Nusselt)</h1></header>

<div class="wrap">
  <div class="card">
    <div class="row" style="grid-template-columns:130px 1fr;">
      <label>Preset</label>
      <select id="preset">
        <option value="fig1b" selected>Fig 1(b) — Bi=1 (locked to caption)</option>
        <option value="custom">Custom (sliders)</option>
      </select>
    </div>

    <div class="kv">
      <button id="loadPreset">Load preset</button>
      <button id="solve">Solve (AGM)</button>
    </div>
    <div id="presetDesc" class="desc"></div>

    <!-- Sliders (enabled in Custom only) -->
    <div class="row"><label>Bi</label><input id="bi" type="range" min="1" max="10000" step="1" value="1"><div class="val" id="bi_v">1</div><div class="hint">solid–fluid exchange</div></div>
    <div class="row"><label>Ra</label><input id="ra" type="range" min="0" max="200" step="1" value="50"><div class="val" id="ra_v">50</div><div class="hint">buoyancy sink</div></div>
    <div class="row"><label>κ = k<sub>s</sub>/k<sub>f</sub></label><input id="kappa" type="range" min="10" max="10000" step="10" value="1000"><div class="val" id="kappa_v">1000</div><div class="hint">solid/fluid conductivity</div></div>
    <div class="row"><label>τ = t/L</label><input id="tau" type="range" min="0.02" max="0.40" step="0.01" value="0.10"><div class="val" id="tau_v">0.10</div><div class="hint">scales Nu</div></div>
    <div class="row"><label>R₁</label><input id="R1" type="range" min="0" max="1" step="0.01" value="0.30"><div class="val" id="R1_v">0.30</div><div class="hint">external radiation</div></div>
    <div class="row"><label>R<sub>d</sub></label><input id="Rd" type="range" min="0" max="0.5" step="0.01" value="0.10"><div class="val" id="Rd_v">0.10</div><div class="hint">internal radiation</div></div>
    <div class="row"><label>φ</label><input id="phi" type="range" min="0.2" max="0.98" step="0.01" value="0.92"><div class="val" id="phi_v">0.92</div><div class="hint">porosity</div></div>

    <div class="kv">
      <button id="download">Download θ CSV</button>
      <span></span>
    </div>

    <div class="small" id="readout"></div>
    <div class="small">
      <span class="badge">BCs: θ_f(0)=θ_s(0)=1</span>
      <span class="badge">θ′_f(1)=θ′_s(1)=0</span>
      <span class="badge">Nu_t = Nu_f + Nu_s</span>
    </div>
  </div>

  <div class="grid3">
    <div class="card"><div id="plot_theta_f" style="height:420px"></div></div>
    <div class="card"><div id="plot_theta_s" style="height:420px"></div></div>
    <div class="card"><div id="plot_nu" style="height:420px"></div></div>
  </div>
</div>

<script>
/* ---------- helpers ---------- */
const $ = id => document.getElementById(id);
const gridColor = "#2a3242";
const staticCfg = {staticPlot:true, responsive:true}; // no zoom/pan, phone-safe
const axes = (xlab,ylab)=>({paper_bgcolor:"transparent",plot_bgcolor:"transparent",
  margin:{l:55,r:10,t:10,b:44},
  xaxis:{title:xlab,gridcolor:gridColor,color:"#cfe0ff"},
  yaxis:{title:ylab,gridcolor:gridColor,color:"#cfe0ff"},
  legend:{font:{color:"#cfe0ff"}}});
const barAxes = {barmode:"stack",paper_bgcolor:"transparent",plot_bgcolor:"transparent",
  margin:{l:65,r:10,t:10,b:44},
  xaxis:{color:"#cfe0ff",title:"method"},
  yaxis:{color:"#cfe0ff",title:"Nusselt (base)"},
  legend:{font:{color:"#cfe0ff"}}};
const FLUID=["#58a6ff","#2f81f7","#1f6feb","#0b4cc2"];
const SOLID=["#34d399","#10b981","#059669","#047857"];

/* ---------- UI ---------- */
const bi=$("bi"), ra=$("ra"), kappa=$("kappa"), tau=$("tau"), R1=$("R1"), Rd=$("Rd"), phi=$("phi");
const bi_v=$("bi_v"), ra_v=$("ra_v"), kappa_v=$("kappa_v"), tau_v=$("tau_v"), R1_v=$("R1_v"), Rd_v=$("Rd_v"), phi_v=$("phi_v");
const preset=$("preset"), presetDesc=$("presetDesc"), readout=$("readout");
let mode="fig1b";

function paintVals(){
  bi_v.textContent=bi.value; ra_v.textContent=ra.value; kappa_v.textContent=kappa.value;
  tau_v.textContent=(+tau.value).toFixed(2); R1_v.textContent=(+R1.value).toFixed(2);
  Rd_v.textContent=(+Rd.value).toFixed(2); phi_v.textContent=(+phi.value).toFixed(2);
}
function readInputs(){return {
  Bi:+bi.value, Ra:+ra.value, kappa:+kappa.value, tau:+tau.value,
  R1:+R1.value, Rd:+Rd.value, phi:+phi.value
};}

/* ---------- linear solver ---------- */
function solveDense(A,b){
  const n=A.length;
  for(let i=0;i<n;i++) A[i]=A[i].slice().concat(b[i]);
  for(let c=0;c<n;c++){
    let p=c, mx=Math.abs(A[c][c]);
    for(let r=c+1;r<n;r++){const v=Math.abs(A[r][c]); if(v>mx){mx=v;p=r;}}
    if(mx<1e-14) throw new Error("Singular");
    if(p!==c){const t=A[p];A[p]=A[c];A[c]=t;}
    const pv=A[c][c];
    for(let j=c;j<=n;j++) A[c][j]/=pv;
    for(let r=0;r<n;r++){
      if(r===c) continue;
      const f=A[r][c]; if(Math.abs(f)<1e-16) continue;
      for(let j=c;j<=n;j++) A[r][j]-=f*A[c][j];
    }
  }
  return A.map(row=>row[n]);
}

/* ---------- model mapping (stable linearized LTNE) ----------
   φ kf θf'' + (-H - Sf) θf + H θs = 0
   keff θs'' + (-H - E ) θs + H θf = 0
   keff = (1-φ) ks + 16 Rd / 3, ks = κ kf, kf := 1
   H = 0.10*Bi,  Sf = 0.02*Ra,  E = 0.20*R1
*/
function params({Bi,Ra,kappa,Rd,R1,phi}){
  const kf=1, ks=kappa;
  const keff=(1-phi)*ks + 16*Rd/3;
  const keq =phi*kf + (1-phi)*ks;
  const H=0.10*Bi, Sf=0.02*Ra, E=0.20*R1;
  return {kf,ks,keff,keq,phi,H,Sf,E};
}

/* ---------- AGM (poly+exp collocation) ---------- */
function solveAGM(inp){
  const {kf,keff,keq,phi,H,Sf,E}=params(inp);
  const m=3, p=2, U=2*((m+1)+p);
  const alphas=[0.8,1.6];

  const M=24, coll=[];
  for(let k=1;k<=M;k++){const z=Math.cos((2*k-1)/(2*M)*Math.PI); coll.push(0.5*(1+z));}
  coll.sort((a,b)=>a-b);

  const A=[], y=[];
  function P(x){return Array.from({length:m+1},(_,i)=>x**i);}
  function d2P(x){return Array.from({length:m+1},(_,i)=> i>1? i*(i-1)*x**(i-2):0);}
  function E0(x){return alphas.map(a=>Math.exp(-a*x));}
  function dE(x){return alphas.map(a=>-a*Math.exp(-a*x));}
  function d2E(x){return alphas.map(a=> a*a*Math.exp(-a*x));}

  for(const x of coll){
    const pf=P(x), ps=pf, d2pf=d2P(x), d2ps=d2P(x);
    const ef=E0(x), es=ef, d2ef=d2E(x), d2es=d2E(x);

    const rF=new Array(U).fill(0);
    for(let i=0;i<=m;i++) rF[i]           += (phi*kf)*d2pf[i] + (-H - Sf)*pf[i];
    for(let j=0;j<p;j++)  rF[(m+1)+j]     += (phi*kf)*d2ef[j] + (-H - Sf)*ef[j];
    for(let i=0;i<=m;i++) rF[(m+1)+p+i]   += H*ps[i];
    for(let j=0;j<p;j++)  rF[(m+1)+p+(m+1)+j] += H*es[j];
    A.push(rF); y.push(0);

    const rS=new Array(U).fill(0); const off=(m+1)+p;
    for(let i=0;i<=m;i++) rS[off+i]       += keff*d2ps[i] + (-H - E)*ps[i];
    for(let j=0;j<p;j++)  rS[off+(m+1)+j] += keff*d2es[j] + (-H - E)*es[j];
    for(let i=0;i<=m;i++) rS[i]           += H*pf[i];
    for(let j=0;j<p;j++)  rS[(m+1)+j]     += H*ef[j];
    A.push(rS); y.push(0);
  }

  (function addBCs(){
    const pf0=P(0), ps0=P(0), ef0=E0(0), es0=E0(0);
    const dpf1=Array.from({length:m+1},(_,i)=> i? i:0), def1=dE(1);
    const dps1=dpf1, des1=def1;

    const rowF0=new Array(U).fill(0);
    for(let i=0;i<=m;i++) rowF0[i]+=pf0[i]; for(let j=0;j<p;j++) rowF0[(m+1)+j]+=ef0[j];
    A.push(rowF0); y.push(1);

    const rowS0=new Array(U).fill(0); const off=(m+1)+p;
    for(let i=0;i<=m;i++) rowS0[off+i]+=ps0[i]; for(let j=0;j<p;j++) rowS0[off+(m+1)+j]+=es0[j];
    A.push(rowS0); y.push(1);

    const rowF1=new Array(U).fill(0);
    for(let i=0;i<=m;i++) rowF1[i]+=dpf1[i]; for(let j=0;j<p;j++) rowF1[(m+1)+j]+=def1[j];
    A.push(rowF1); y.push(0);

    const rowS1=new Array(U).fill(0);
    for(let i=0;i<=m;i++) rowS1[(m+1)+p+i]+=dps1[i]; for(let j=0;j<p;j++) rowS1[(m+1)+p+(m+1)+j]+=des1[j];
    A.push(rowS1); y.push(0);
  })();

  const AT=A[0].map((_,j)=>A.map(r=>r[j]));
  const ATA=AT.map(row=>AT.map((_,j)=>row.reduce((s,rij,i)=>s+rij*A[i][j],0)));
  const ATy=AT.map(row=>row.reduce((s,rij,i)=>s+rij*y[i],0));
  const c=solveDense(ATA,ATy);

  const N=161, x=Array.from({length:N},(_,i)=>i/(N-1));
  function evalTheta(isF,xv){
    let s=0, off=(m+1)+p;
    if(isF){ for(let i=0;i<=m;i++) s+=c[i]*xv**i; for(let j=0;j<p;j++) s+=c[(m+1)+j]*Math.exp(-alphas[j]*xv); }
    else   { for(let i=0;i<=m;i++) s+=c[off+i]*xv**i; for(let j=0;j<p;j++) s+=c[off+(m+1)+j]*Math.exp(-alphas[j]*xv); }
    return s;
  }
  function derivAt0(isF){
    let s=0, off=(m+1)+p;
    if(isF){ for(let j=0;j<p;j++) s+=c[(m+1)+j]*(-alphas[j]); }
    else   { for(let j=0;j<p;j++) s+=c[off+(m+1)+j]*(-alphas[j]); }
    return s;
  }

  const thetaF=x.map(v=>evalTheta(true,v));
  const thetaS=x.map(v=>evalTheta(false,v));
  const dthetaf0=derivAt0(true);
  const dthetas0=derivAt0(false);

  const Nu_f=-(inp.phi*1/ (inp.phi + (1-inp.phi)*inp.kappa) )*inp.tau*dthetaf0;
  const Nu_s=-(((1-inp.phi)*inp.kappa + 16*inp.Rd/3) / (inp.phi + (1-inp.phi)*inp.kappa) )*inp.tau*dthetas0;
  const Nu_t=Nu_f+Nu_s;

  return {x,thetaF,thetaS,Nu_f,Nu_s,Nu_t,dthetaf0,dthetas0};
}

/* ---------- renderers ---------- */
function renderSingle(inp){
  const S=solveAGM(inp ?? readInputs());
  Plotly.newPlot("plot_theta_f",[
    {x:S.x,y:S.thetaF,name:"θ_f (AGM)",mode:"lines",line:{width:3,color:FLUID[1]}}
  ],axes("x","θ_f"),staticCfg);
  Plotly.newPlot("plot_theta_s",[
    {x:S.x,y:S.thetaS,name:"θ_s (AGM)",mode:"lines",line:{width:3,color:SOLID[1]}}
  ],axes("x","θ_s"),staticCfg);
  Plotly.newPlot("plot_nu",[
    {x:["AGM"],y:[S.Nu_f],name:"Nu_f",type:"bar",marker:{color:FLUID[2]}},
    {x:["AGM"],y:[S.Nu_s],name:"Nu_s",type:"bar",marker:{color:SOLID[2]}}
  ],barAxes,staticCfg).then(()=>{
    Plotly.relayout("plot_nu",{annotations:[{x:"AGM",y:S.Nu_t,text:`Nuₜ=${S.Nu_t.toFixed(4)}`,showarrow:false,yshift:12,font:{color:"#a7d0ff"}}]});
  });
  readout.innerHTML=`Bi=${inp?.Bi ?? bi.value}, Ra=${inp?.Ra ?? ra.value}, τ=${(inp?.tau ?? tau.value)} | Nu_f=<b>${S.Nu_f.toFixed(5)}</b>, Nu_s=<b>${S.Nu_s.toFixed(5)}</b>, Nu_t=<b>${S.Nu_t.toFixed(5)}</b>`;
}

/* ---------- presets ---------- */
function applyPreset(key){
  mode=key;
  // Fig 1(b) caption values:
  const fig1b={Bi:1, Ra:50, tau:0.10, Rd:0.10, R1:0.30, phi:0.92, kappa:1000};
  if(key==="fig1b"){
    bi.value=fig1b.Bi; ra.value=fig1b.Ra; kappa.value=fig1b.kappa; tau.value=fig1b.tau;
    R1.value=fig1b.R1; Rd.value=fig1b.Rd; phi.value=fig1b.phi; paintVals();
    presetDesc.textContent="Fig 1(b): θ_f and θ_s at Bi=1 (Ra=50, τ=0.1, R_d=0.1, R₁=0.3, φ=0.92, κ=1000).";
    // Lock sliders visually unless Custom
    [bi,ra,kappa,tau,R1,Rd,phi].forEach(e=>e.disabled=true);
    renderSingle(fig1b);
    return;
  }
  // Custom: sliders enabled
  [bi,ra,kappa,tau,R1,Rd,phi].forEach(e=>e.disabled=false);
  presetDesc.textContent="Custom: move sliders and Solve (AGM).";
  paintVals();
  renderSingle();
}

/* ---------- CSV ---------- */
$("download").addEventListener("click",()=>{
  const S=solveAGM(readInputs());
  const rows=["x,theta_f,theta_s"];
  for(let i=0;i<S.x.length;i++) rows.push(`${S.x[i].toFixed(6)},${S.thetaF[i].toFixed(9)},${S.thetaS[i].toFixed(9)}`);
  const blob=new Blob([rows.join("\n")],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download="ltne_agm_theta_fig1b_or_custom.csv"; a.click();
  URL.revokeObjectURL(url);
});

/* ---------- wire ---------- */
$("solve").addEventListener("click",()=>renderSingle());
$("loadPreset").addEventListener("click",()=>applyPreset(preset.value));
[bi,ra,kappa,tau,R1,Rd,phi].forEach(e=>e.addEventListener("input",()=>{ if(mode==="custom") renderSingle(); }));

// boot straight into Fig 1(b)
applyPreset("fig1b");
</script>
</body>
</html>
